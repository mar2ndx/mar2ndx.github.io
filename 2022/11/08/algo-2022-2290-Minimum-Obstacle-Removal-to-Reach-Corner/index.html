<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    2290. Minimum Obstacle Removal to Reach Corner 丨
    

    typo
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">Tech blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">2290. Minimum Obstacle Removal to Reach Corner</div>
  <div class="post-meta">
    <div class="date">2022 November 8th</div>
    <div class="tags">
      
    </div>
  </div>
  

  <main class="post-content"><p>Link: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/">https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/</a></p>
<h1 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h1><p>difficulty: hard<br>adj diff: 4</p>
<pre><code>You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:

	0 represents an empty cell,
	1 represents an obstacle that may be removed.

You can move up, down, left, or right from and to an empty cell.

Return the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).
Example 1:

Input: grid = [[0,1,1],[1,1,0],[1,1,0]]
Output: 2
Explanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).
It can be shown that we need to remove at least 2 obstacles, so we return 2.
Note that there may be other ways to remove 2 obstacles to create a path.

Example 2:

Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]
Output: 0
Explanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0.
Constraints:

	m == grid.length
	n == grid[i].length
	1 &lt;= m, n &lt;= 105
	2 &lt;= m * n &lt;= 105
	grid[i][j] is either 0 or 1.
	grid[0][0] == grid[m - 1][n - 1] == 0
</code></pre>
<p>这道题没有想象的那么难：就是基础的 bfs。</p>
<p>只不过，涉及到一个路线长短的问题。也就是：</p>
<ol>
<li>不遇到障碍物（即 grid[i][j] &#x3D;&#x3D; 0 情况），则路线长度为 0；</li>
<li>如遇到了障碍（即 grid[i][j] &#x3D;&#x3D; 1 情况），则路线长度为 1；</li>
<li>BFS + 算出最短长度。</li>
</ol>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>代码是我参考的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public int minimumObstacles(int[][] grid) &#123;</span><br><span class="line">    int m = grid.length;</span><br><span class="line">    int n = grid[0].length;</span><br><span class="line">    int[][] dirs = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    // int[][] dist is the visited map + distance from [0, 0]</span><br><span class="line">    int[][] dist = new int[m][n];</span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            // first, all distances are very very far</span><br><span class="line">            if (i + j == 0) dist[i][j] = 0;</span><br><span class="line">            else dist[i][j] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // start BFS</span><br><span class="line">    List&lt;int[]&gt; q = new LinkedList&lt;int[]&gt;();</span><br><span class="line">    q.add(new int[]&#123;0, 0&#125;);</span><br><span class="line">    while (!q.isEmpty()) &#123;</span><br><span class="line">        int[] pos = q.remove(0);</span><br><span class="line">        int x = pos[0];</span><br><span class="line">        int y = pos[1];</span><br><span class="line">        for (int[] ttt: dirs) &#123;</span><br><span class="line">            int nextX = x + ttt[0];</span><br><span class="line">            int nextY = y + ttt[1];</span><br><span class="line"></span><br><span class="line">            // 从dist[x][y]走到dist[nextX][nextY]，需要跨过grid[nextX][nextY]</span><br><span class="line">            if (nextX &lt; 0 || nextX &gt;= m || nextY &lt; 0 || nextY &gt;= n) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">				// [nextX][nextY] is a valid position,</span><br><span class="line">                // Now I need to update distance[nextX][nextY]</span><br><span class="line">				int stepDistance = dist[x][y] + grid[nextX][nextY];</span><br><span class="line">                if (stepDistance &lt; dist[nextX][nextY]) &#123;</span><br><span class="line">                    dist[nextX][nextY] = stepDistance;</span><br><span class="line">                    q.add(new int[]&#123;nextX, nextY&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dist[m - 1][n - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2024 typo</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>