<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    [LeetCode 3] Longest Substring Without Repeating Characters 丨
    

    typo
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">Tech blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">[LeetCode 3] Longest Substring Without Repeating Characters</div>
  <div class="post-meta">
    <div class="date">2014 April 27th</div>
    <div class="tags">
      
    </div>
  </div>
  

  <main class="post-content"><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p><a target="_blank" rel="noopener" href="http://oj.leetcode.com/problems/longest-substring-without-repeating-characters/">link</a></p>
<div class="question-content">
<p></p><p>Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for "abcabcbb" is "abc", which the length is 3. For "bbbbb" the longest substring is "b", with the length of 1.</p>
<p></p></div>

<h3 id="Stats"><a href="#Stats" class="headerlink" title="Stats"></a>Stats</h3><table border="2">
	<tr>
		<td>Frequency</td>
		<td bgcolor="lime">2</td>
	</tr>
	<tr>
		<td>Diffficulty</td>
		<td bgcolor="yellow">3</td>
	</tr>
	<tr>
		<td>Adjusted Difficulty</td>
		<td bgcolor="red">4</td>
	</tr>
	<tr>
		<td>Time to use</td>
		<td bgcolor="red">----------</td>
	</tr>
</table>

<p>Ratings&#x2F;Color &#x3D; 1(white) 2(lime) 3(yellow) 4&#x2F;5(red)</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>This question looks easy (well, isn’t it?), but it <strong>really is not easy</strong>!.</p>
<p><strong>The main idea is</strong>: an array of int(128) is used to keep track of the last occurance position of each character. So we iterate thru the characters while constently checking the last occurrence of the letter. Meanwhile, keep updating the longest distance.</p>
<p><strong>There is 1 place where it’s extremely easy to make mistake</strong>, that is the condition of update left points:</p>
<pre><code>if (previousPos != -1&amp;&amp; previousPos &gt;= left) &#123;
    left = previousPos + 1;
&#125;
</code></pre>
<p>If you have an idea of using array int(128) to <strong>store last occurrence</strong>, and you got the above <strong>if condition</strong> correct, then you nailed it!</p>
<p>Again, this is a tough question. There’s a seemingly more intuitive solution using the sliding window method. It’s very similar to [LeetCode 76] Minimum Window Substring.</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Note what happens when a repeating char is found (2 different conditions).</p>
<p><img src="/images/longest-without-repeat.png"></p>
<h3 id="My-code"><a href="#My-code" class="headerlink" title="My code"></a>My code</h3><p>The proper way:</p>
<pre><code>public class Solution &#123;
    public int lengthOfLongestSubstring(String s) &#123;
        if (s == null || s.length() == 0) &#123;
            return 0;
        &#125;

        int[] flag = new int[128];
        for (int i = 0; i &lt; flag.length; i++) &#123;
            flag[i] = -1;
        &#125;
        // left and right pointer defines the valid range
        int left = 0;
        int right = 0;
        int longest = 0;
        int len = s.length();

        while (right &lt; len) &#123;
            char letter = s.charAt(right);
            int previousPos = flag[letter];
            if (previousPos != -1&amp;&amp; previousPos &gt;= left) &#123;
                // if right pointer points to an old letter, and is within current range
                // then we need to update our left pointer:
                // to bypass the previous occurrence of that letter
                left = previousPos + 1;
            &#125;
            flag[letter] = right;
            // advance right pointer to the next letter, and calculate longest distance
            right++;
            longest = Math.max(longest, right - left);
        &#125;
        return longest;
    &#125;
&#125;
</code></pre>
<p>The sliding window way:</p>
<pre><code>public class Solution &#123;
    public int lengthOfLongestSubstring(String s) &#123;
        if (s == null || s.length() == 0) &#123;
            return 0;
        &#125;
        int len = s.length();
        int left = 0;
        int right = 1;
        HashSet&lt;Character&gt; set = new HashSet&lt;Character&gt;();
        set.add(s.charAt(0));
        int longest = 1;
        while (right &lt; len) &#123;
            // right pointer proceeds until boundary or duplicate char found
            while (right &lt; len &amp;&amp; !set.contains(s.charAt(right))) &#123;
                set.add(s.charAt(right));
                right++;
                longest = Math.max(longest, right - left);
            &#125;
            if (right == len) &#123;
                return longest;
            &#125; else &#123;
                // right pointer has reached a duplicate char.
                // now move left pointer until that dup char is found
                while (s.charAt(left) != s.charAt(right)) &#123;
                    set.remove(s.charAt(left));
                    left++;
                &#125;
                // left pointer advance by one to bypass the dup char
                left++;
                // right pointer advance by one to include the dup char
                right++;
            &#125;
        &#125;
        return Math.max(longest, right - left);
    &#125;
&#125;
</code></pre>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2024 typo</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>