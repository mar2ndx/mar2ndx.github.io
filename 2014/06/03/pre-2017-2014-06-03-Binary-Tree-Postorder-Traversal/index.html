<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">





<title>[LeetCode 145] Binary Tree Postorder Traversal | Tech blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const pagebody = document.getElementsByTagName('body')[0]

            function setTheme(status) {

                if (status === 'dark') {
                    window.sessionStorage.theme = 'dark'
                    pagebody.classList.add('dark-theme');

                } else if (status === 'light') {
                    window.sessionStorage.theme = 'light'
                    pagebody.classList.remove('dark-theme');
                }
            };

            setTheme(window.sessionStorage.theme)
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Bentham&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/category">Categories</a>
                
                <a class="menu-item" href="/tag">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Bentham&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">
                    <svg class="menu-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M4.5 17.27q-.213 0-.356-.145T4 16.768t.144-.356t.356-.143h15q.213 0 .356.144q.144.144.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.144T4 11.999t.144-.356t.356-.143h15q.213 0 .356.144t.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.143Q4 7.443 4 7.23t.144-.356t.356-.143h15q.213 0 .356.144T20 7.23t-.144.356t-.356.144z"/></svg>
                    <svg class="close-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Material Symbols Light by Google - https://github.com/google/material-design-icons/blob/master/LICENSE --><path fill="currentColor" d="m12 12.708l-5.246 5.246q-.14.14-.344.15t-.364-.15t-.16-.354t.16-.354L11.292 12L6.046 6.754q-.14-.14-.15-.344t.15-.364t.354-.16t.354.16L12 11.292l5.246-5.246q.14-.14.345-.15q.203-.01.363.15t.16.354t-.16.354L12.708 12l5.246 5.246q.14.14.15.345q.01.203-.15.363t-.354.16t-.354-.16z"/></svg>
                </div>
            </div>
            <div class="menu" id="mobile-menu">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/category">Categories</a>
                
                <a class="menu-item" href="/tag">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">[LeetCode 145] Binary Tree Postorder Traversal</h1>
            
                <div class="post-meta">
                    

                    
                        <span class="post-time">
                        Date: <a href="#">June 3, 2014&nbsp;&nbsp;0:00:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Leetcode/">Leetcode</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p><a target="_blank" rel="noopener" href="https://oj.leetcode.com/problems/binary-tree-postorder-traversal/">link</a></p>
<div class="question-content bg-color bg-img font-color">
            <p class="font-color"></p><p class="font-color">Given a binary tree, return the <i>postorder</i> traversal of its nodes' values.</p>

<p class="font-color">
For example:<br>
Given binary tree <code>&#123;1,#,2,3&#125;</code>,<br>
</p><pre>   1
    \
     2
    /
   3
</pre>
<p class="font-color"></p>
<p class="font-color">
return <code>[3,2,1]</code>.
</p>

<p class="font-color"><b>Note:</b> Recursive solution is trivial, could you do it iteratively?</p><p class="font-color"></p>
          </div>

<h3 id="Stats"><a href="#Stats" class="headerlink" title="Stats"></a>Stats</h3><table border="2">
	<tr>
		<td>Adjusted Difficulty</td>
		<td bgcolor="red">4</td>
	</tr>
	<tr>
		<td>Time to use</td>
		<td bgcolor="yellow">--------</td>
	</tr>
</table>

<p>Ratings&#x2F;Color &#x3D; 1(white) 2(lime) 3(yellow) 4&#x2F;5(red)</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Unlike pre-order traversal, <strong>this is a very difficult question</strong>.</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p><strong>First, I wrote the solution using a HashSet, and it works</strong>. However, this solution is not good because it uses some space.<br>For more generalized way to write DFS code, read another post <strong>Implement DFS using a Stack</strong>.</p>
<p><strong>The best and most popular solution is proposed by <a target="_blank" rel="noopener" href="http://leetcode.com/2010/10/binary-tree-post-order-traversal.html">1337c0d3r</a></strong>. It basically uses 1 more pointer to track the current status (whether I’m traversing down, or up, and in which direction etc.). The extra pointer is called ‘prev’.</p>
<blockquote>
<p>We use a prev variable to keep track of the previously-traversed node. Let’s assume curr is the current node that’s on top of the stack. When prev is curr‘s parent, we are traversing down the tree. In this case, we try to traverse to curr‘s left child if available (ie, push left child to the stack). If it is not available, we look at curr‘s right child. If both left and right child do not exist (ie, curr is a leaf node), we print curr‘s value and pop it off the stack.</p>
</blockquote>
<blockquote>
<p>If prev is curr‘s left child, we are traversing up the tree from the left. We look at curr‘s right child. If it is available, then traverse down the right child (ie, push right child to the stack), otherwise print curr‘s value and pop it off the stack.</p>
</blockquote>
<blockquote>
<p>If prev is curr‘s right child, we are traversing up the tree from the right. In this case, we print curr‘s value and pop it off the stack.</p>
</blockquote>
<p>Referring to his code, I wrote the 2nd piece of code below and it works.</p>
<p><strong>Amazingly, that code can be simplified, which becomes the 3rd code</strong> (I thought it won’t pass at first). The way that code got simplified is by keeping current pointer steady, so that the 2 pointers can meet. Altough program logic is exactly same, this interesting code is worth reading.</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><strong>First, my solution using HashSet</strong></p>
<pre><code>public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;
    List&lt;Integer&gt; ans = new LinkedList&lt;Integer&gt;();
    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
    if (root != null) stack.push(root);
    HashSet&lt;TreeNode&gt; visited = new HashSet&lt;TreeNode&gt;();
    while (!stack.isEmpty()) &#123;
		TreeNode cur = stack.pop();
		if (visited.contains(cur))
			ans.add(cur.val);
		else &#123;
			stack.push(cur);
			visited.add(cur);
			if (cur.right != null) stack.push(cur.right);
			if (cur.left != null) stack.push(cur.left);
		&#125;
    &#125;
    return ans;
&#125;
</code></pre>
<p><strong>Second, using 2 pointers</strong></p>
<pre><code>public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;
    List&lt;Integer&gt; ans = new LinkedList&lt;Integer&gt;();
    if (root == null) &#123;
		return ans;
	&#125;
	Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
    stack.push(root);
    TreeNode pre = null, cur = null;
	while (!stack.isEmpty()) &#123;
		cur = stack.peek();
		if (pre == null || pre.left == cur || pre.right == cur) &#123;
			if (cur.left == null &amp;&amp; cur.right == null) &#123;
				ans.add(stack.pop().val);
			&#125;
			else if (cur.left != null) &#123;
				stack.push(cur.left);
			&#125;
			else if (cur.right != null) &#123;
				stack.push(cur.right);
			&#125;
		&#125;
		else if (cur.left == pre) &#123;
			if (cur.right != null) &#123;
				stack.push(cur.right);
			&#125;
			else &#123;
				ans.add(stack.pop().val);
			&#125;
		&#125;
		else if (cur.right == pre) &#123;
			ans.add(stack.pop().val);
		&#125;
		pre = cur;
	&#125;
    return ans;
&#125;
</code></pre>
<p><strong>Third, simplified version of 2nd code</strong></p>
<p><strong>Commented on June 10th</strong>: Note that ‘pre’ and ‘cur’ are never going to be apart for more then 1 edge (they can overlap)</p>
<pre><code>public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;
	List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();
	Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();
	TreeNode prev = null; // previously traversed node
	TreeNode curr = root;
	if (root == null) &#123;
		return result;
	&#125;
	stack.push(root);
	while (!stack.empty()) &#123;
		curr = stack.peek();
		if (prev == null || prev.left == curr || prev.right == curr) &#123;
        // traverse down the tree
			if (curr.left != null) &#123;
				stack.push(curr.left);
			&#125; else if (curr.right != null) &#123;
				stack.push(curr.right);
			&#125;
		&#125; else if (curr.left == prev) &#123;
        // traverse up the tree from the left
			if (curr.right != null) &#123;
				stack.push(curr.right);
			&#125;
		&#125; else if (curr.right == prev || curr == prev)&#123;
        // traverse up the tree from the right
        // or at a leaf point
			result.add(curr.val);
			stack.pop();
		&#125;
		prev = curr;
	&#125;
	return result;
&#125;
</code></pre>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://mar2ndx.github.io/2014/06/03/pre-2017-2014-06-03-Binary-Tree-Postorder-Traversal/">https://mar2ndx.github.io/2014/06/03/pre-2017-2014-06-03-Binary-Tree-Postorder-Traversal/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2014/06/03/pre-2017-2014-06-03-Big-endian-little-endian/">[Design] Big Endian and Little Endian</a>
            
            
            <a class="next" rel="next" href="/2014/06/03/pre-2017-2014-06-03-Evaluate-Reverse-Polish-Notation/">[LeetCode 150] Evaluate Reverse Polish Notation</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>©  | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>