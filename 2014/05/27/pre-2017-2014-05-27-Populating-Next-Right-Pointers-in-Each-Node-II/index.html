<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">





<title>[LeetCode 117] Populating Next Right Pointers in Each Node II | Tech blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const pagebody = document.getElementsByTagName('body')[0]

            function setTheme(status) {

                if (status === 'dark') {
                    window.sessionStorage.theme = 'dark'
                    pagebody.classList.add('dark-theme');

                } else if (status === 'light') {
                    window.sessionStorage.theme = 'light'
                    pagebody.classList.remove('dark-theme');
                }
            };

            setTheme(window.sessionStorage.theme)
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Tech Blog</a></div>
            <div class="menu navbar-right">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/category">Categories</a>
                
                <a class="menu-item" href="/tag">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Tech Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">
                    <svg class="menu-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M4.5 17.27q-.213 0-.356-.145T4 16.768t.144-.356t.356-.143h15q.213 0 .356.144q.144.144.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.144T4 11.999t.144-.356t.356-.143h15q.213 0 .356.144t.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.143Q4 7.443 4 7.23t.144-.356t.356-.143h15q.213 0 .356.144T20 7.23t-.144.356t-.356.144z"/></svg>
                    <svg class="close-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Material Symbols Light by Google - https://github.com/google/material-design-icons/blob/master/LICENSE --><path fill="currentColor" d="m12 12.708l-5.246 5.246q-.14.14-.344.15t-.364-.15t-.16-.354t.16-.354L11.292 12L6.046 6.754q-.14-.14-.15-.344t.15-.364t.354-.16t.354.16L12 11.292l5.246-5.246q.14-.14.345-.15q.203-.01.363.15t.16.354t-.16.354L12.708 12l5.246 5.246q.14.14.15.345q.01.203-.15.363t-.354.16t-.354-.16z"/></svg>
                </div>
            </div>
            <div class="menu" id="mobile-menu">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/category">Categories</a>
                
                <a class="menu-item" href="/tag">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">[LeetCode 117] Populating Next Right Pointers in Each Node II</h1>
            
                <div class="post-meta">
                    

                    
                        <span class="post-time">
                        Date: <a href="#">May 27, 2014&nbsp;&nbsp;0:00:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Leetcode/">Leetcode</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p><a target="_blank" rel="noopener" href="https://oj.leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/">link</a></p>
<div class="question-content">
            <p></p><p>Follow up for problem "<i>Populating Next Right Pointers in Each Node</i>".</p>
<p>What if the given tree could be any binary tree? Would your previous solution still work?</p>
<p>
<b>Note:</b>
</p><ul><li>You may only use constant extra space.</li></ul>
<p></p>
<p>
For example,<br>
Given the following binary tree,<br>
</p><pre>         1
       /  \
      2    3
     / \    \
    4   5    7
</pre>
<p></p>
<p>
After calling your function, the tree should look like:<br>
</p><pre>         1 -&gt; NULL
       /  \
      2 -&gt; 3 -&gt; NULL
     / \    \
    4-&gt; 5 -&gt; 7 -&gt; NULL
</pre>
<p></p><p></p>
          </div>

<h3 id="Stats"><a href="#Stats" class="headerlink" title="Stats"></a>Stats</h3><table border="2">
	<tr>
		<td>Frequency</td>
		<td bgcolor="lime">2</td>
	</tr>
	<tr>
		<td>Difficulty</td>
		<td bgcolor="red">4</td>
	</tr>
	<tr>
		<td>Adjusted Difficulty</td>
		<td bgcolor="red">4</td>
	</tr>
	<tr>
		<td>Time to use</td>
		<td bgcolor="red">--------</td>
	</tr>
</table>

<p>Ratings&#x2F;Color &#x3D; 1(white) 2(lime) 3(yellow) 4&#x2F;5(red)</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p><strong>This is a difficult question</strong>.</p>
<p>We can of course do a BFS, but that’s too simple, and it’s not related to previous question, thus <strong>Queue</strong> is not the answer we’re looking for.</p>
<p><strong>There are 2 ways to solve this problem, recursively and iteratively</strong>. The 2 solutions are quite different, I will explain them.</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p><strong>First solution is non-recursion, which is from <a target="_blank" rel="noopener" href="http://rleetcode.blogspot.sg/2014/03/follow-up-for-problem-populating-next.html">this blog</a></strong>. First we declare a pointer ‘cur’ that points to a node. We assume the ‘next-links’ are already built in current level, and our job is to generate the ‘next-links’ for the next level.</p>
<p>In order to do that, we need another 2 pointers in the next level (one head and one tail) to keep track of the position till where we have finished building the links. So ‘cur’ keep traversing thru current level, until it reaches the end. Then, we move ‘cur’ to the head of next level, and continue the process.</p>
<p>The coding part is not difficult, <strong>which is not the case for next solution</strong>.</p>
<p><strong>Second solution is recursive, and it is written in <a target="_blank" rel="noopener" href="http://fisherlei.blogspot.sg/2012/12/leetcode-populating-next-right-pointers_29.html">this blog</a></strong>. Same as previous solution, we assume that current level have all ‘next-links’ ready, and we will build these links for next level.</p>
<p>The way of getting next link for child nodes is a bit different, but I guess that’s fine. The difficult part is <strong>during recursive call, I NEED TO CALL THE RECURSION METHOD FOR RIGHT CHILD FIRST, THEN LEFT CHILD</strong>. The reason is, the links from left child to right child is going to be used in the recursion call. If we do left first, we will have problem getting <strong>current.left.next</strong> (which in this case, will be null). I spent a terribly long time debugging this error, until I found a great explanation <a target="_blank" rel="noopener" href="https://oj.leetcode.com/discuss/1942/anyone-helps-to-find-bug-for-my-code">here</a>.</p>
<blockquote>
<p>in your code: connect(root-&gt;left); connect(root-&gt;right);</p>
</blockquote>
<blockquote>
<p>which means you first recurs left sub-tree, then right subtree. The problem is the right subtree’s next pointers are not processed. So in your example, 9-&gt;next should be 1, however, when you traverse the left sub tree, 9’s next pointer is still NULL. Your code will think 9 is the end of the third level, so the fourth level’s 0 will have its next to be NULL.</p>
</blockquote>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><strong>First, my initial solution making use of queue</strong>. It is around 50ms slower than the other solutions.</p>
<pre><code>public void connect(TreeLinkNode root) &#123;
    if (root == null) return;
    LinkedList&lt;TreeLinkNode&gt; list = new LinkedList&lt;TreeLinkNode&gt;();
    list.add(root);
    while (! list.isEmpty()) &#123;
        LinkedList&lt;TreeLinkNode&gt; newList = new LinkedList&lt;TreeLinkNode&gt;();
        while (! list.isEmpty()) &#123;
            TreeLinkNode node = list.remove();
            if (! list.isEmpty()) node.next = list.get(0);
            if (node.left != null) newList.add(node.left);
            if (node.right != null) newList.add(node.right);
        &#125;
        list = newList;
    &#125;
&#125;
</code></pre>
<p><strong>Second, non-recursion solution</strong></p>
<pre><code>public void connect(TreeLinkNode root) &#123;
    TreeLinkNode nextLevelHead = null;
    TreeLinkNode nextLevelTail = null;
    TreeLinkNode cur = root;
    while (cur != null) &#123;
        if (cur.left != null) &#123;
            if (nextLevelHead == null) &#123;
                nextLevelHead = cur.left;
                nextLevelTail = cur.left;
            &#125;
            else &#123;
                nextLevelTail.next = cur.left;
                nextLevelTail = cur.left;
            &#125;
        &#125;
        if (cur.right != null) &#123;
            if (nextLevelHead == null) &#123;
                nextLevelHead = cur.right;
                nextLevelTail = cur.right;
            &#125;
            else &#123;
                nextLevelTail.next = cur.right;
                nextLevelTail = cur.right;
            &#125;
        &#125;
        cur = cur.next;
        if (cur == null) &#123;
            cur = nextLevelHead;
            nextLevelHead = null;
            nextLevelTail = null;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>Third, recursive solution</strong></p>
<pre><code>public void connect(TreeLinkNode root) &#123;
    if (root == null) return;
    // now find root.next&#39;s valid child
    TreeLinkNode n = root.next, nextLevelNext = null;
    while (n != null &amp;&amp; nextLevelNext == null) &#123;
        if (n.left != null) &#123;
            nextLevelNext = n.left;
            break;
        &#125;
        if (n.right != null) &#123;
            nextLevelNext = n.right;
            break;
        &#125;
        n = n.next;
    &#125;
    // now nextLevelNext is fetched
    if (root.right != null)
        root.right.next = nextLevelNext;
    if (root.left != null)
        root.left.next = root.right == null ? nextLevelNext : root.right;
    // recursion call
    connect(root.right);
    connect(root.left);
&#125;
</code></pre>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://mar2ndx.github.io/2014/05/27/pre-2017-2014-05-27-Populating-Next-Right-Pointers-in-Each-Node-II/">https://mar2ndx.github.io/2014/05/27/pre-2017-2014-05-27-Populating-Next-Right-Pointers-in-Each-Node-II/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2014/05/27/pre-2017-2014-05-27-Path-Sum/">[LeetCode 112] Path Sum</a>
            
            
            <a class="next" rel="next" href="/2014/05/27/pre-2017-2014-05-27-Populating-Next-Right-Pointers-in-Each-Node/">[LeetCode 116] Populating Next Right Pointers in Each Node</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>©  | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>