<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
  <title>
    
    [LeetCode 114] Flatten Binary Tree to Linked List 丨
    

    typo
  </title>

  
  <link rel="shortcut icon" href="/icon.svg">
  

  <link rel="preconnect" href="https://cdnjs.cloudflare.com">
  
  <link id="theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.css">
  <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
  

  <!-- 字体 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet">

  
<link rel="stylesheet" href="/css/root.css">

  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/post.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <header class="header">
  <section class="header-container">
    <a class="logo" href="/">Tech blog</a>
    <ul class="nav">
      
      <li><a href="/archives">archives</a></li>
      
      <li><a href="/about">about</a></li>
      
    </ul>
  </section>
</header>
  <main class="main">
    <article class="post">
  
  <div class="post-title">[LeetCode 114] Flatten Binary Tree to Linked List</div>
  <div class="post-meta">
    <div class="date">2014 May 28th</div>
    <div class="tags">
      
    </div>
  </div>
  

  <main class="post-content"><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p><a target="_blank" rel="noopener" href="https://oj.leetcode.com/problems/flatten-binary-tree-to-linked-list/">link</a></p>
<div class="question-content">
            <p></p><p>
Given a binary tree, flatten it to a linked list in-place.
</p>

<p>
For example,<br>
Given
</p><pre>         1
        / \
       2   5
      / \   \
     3   4   6
</pre>
<p></p>

<p>The flattened tree should look like:<br></p>
<pre>   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6
</pre>

<div class="spoilers" ><b>Hints:</b>
<p>If you notice carefully in the flattened tree, each node's right child points to the next node of a pre-order traversal.</p>
</div><p></p>
          </div>

<h3 id="Stats"><a href="#Stats" class="headerlink" title="Stats"></a>Stats</h3><table border="2">
	<tr>
		<td>Frequency</td>
		<td bgcolor="yellow">3</td>
	</tr>
	<tr>
		<td>Difficulty</td>
		<td bgcolor="yellow">3</td>
	</tr>
	<tr>
		<td>Adjusted Difficulty</td>
		<td bgcolor="red">4</td>
	</tr>
	<tr>
		<td>Time to use</td>
		<td bgcolor="red">--------</td>
	</tr>
</table>

<p>Ratings&#x2F;Color &#x3D; 1(white) 2(lime) 3(yellow) 4&#x2F;5(red)</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p><strong>This is a very difficult question</strong>, and there are many solutions.</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p><strong>Analysis of all solutions (except first one) is found in <a target="_blank" rel="noopener" href="http://n00tc0d3r.blogspot.sg/2013/03/flatten-binary-tree-to-linked-list-in.html">this great article</a></strong>.</p>
<p><strong>Solution 1 is my code</strong>, I am make use of a ‘pre’ pointer in this recursive method. This idea is actually quite good, but is never seen in any other people’s blogs.</p>
<p><strong>Solution 2 is the most standard recursive solution</strong>. It passes in a node, flatten it and return the last node after it’s flattened. So we can flatten root node’s left and right node respectively, and then connect it.</p>
<blockquote cite="http://n00tc0d3r.blogspot.sg/2013/03/flatten-binary-tree-to-linked-list-in.html">
To flatten a binary tree, according to the given example, is to recursively insert the left subtree to the right subtree and append the original right subtree to the end of the left subtree, i.e.<br>
<pre>     root                        root
     /  \            -&gt;            \
  left  right                      left
                                     \
                                    right
</pre>
Since we need to append the original right-tree to the end of the left subtree, we let the recursion function return the last node after flatten.
</blockquote>

<p>I missed “root.left &#x3D; null” while coding, and it resulted in long long time debugging. I think this is a very silly mistake.</p>
<p><strong>Solution 3 is making use of a stack</strong>. I have to say, although I can figure how it works, I am still blur about the thinking process of this entire idea. Which is to say, I can’t keep it in mind even after learning it.</p>
<p>I shall try write this code in the future.</p>
<blockquote>
We can also solve the problem without recursion.<br>
<br>
To do that, we can use a stack to store all right subtrees when we prune them temporarily, and append each of them back after we go through the corresponding left subtree.<br>
<br>
Basically, given a non-empty tree,<br>
<ul>
<li>if it has left subtree, store the right subtree (if not null) to stack, move the left subtree to right;</li>
<li>if not, append back a subtree from stack to the current node's right;</li>
<li>continue to the right node until finish.</li>
</ul>
</blockquote>

<p><strong>Solution 4 is what I believe the best solution</strong>. It simple uses while loop to put all nodes in the correct position, without recursion or stack.</p>
<blockquote>
<p>Each time when we prune a right subtree, we use while-loop to find the right-most leaf of the current left subtree, and append the subtree there.</p>
</blockquote>
<p><strong>Analysis of all solutions (except first one) is found in <a target="_blank" rel="noopener" href="http://n00tc0d3r.blogspot.sg/2013/03/flatten-binary-tree-to-linked-list-in.html">this great article</a></strong>.</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><strong>First, my solution</strong>, a kind of recursive solution</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void flatten(TreeNode root) &#123;</span><br><span class="line">    helper(new TreeNode(1234), root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private TreeNode helper(TreeNode pre, TreeNode node) &#123;</span><br><span class="line">    // pre cannot be null, this function return the last node of the flatten list</span><br><span class="line">    if (node == null) return pre;</span><br><span class="line">    pre.left = null;</span><br><span class="line">    pre.right = node;</span><br><span class="line">    TreeNode a = node.left;</span><br><span class="line">    TreeNode b = node.right;</span><br><span class="line">    TreeNode temp = helper(node, a);</span><br><span class="line">    return helper(temp, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Second, standard recursive solution</strong></p>
<p>看这里：helper function 的 return value 是 tail node，不是 head node。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void flatten(TreeNode root) &#123;</span><br><span class="line">    helper(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private TreeNode helper(TreeNode root) &#123;</span><br><span class="line">    if (root == null) return null;</span><br><span class="line">    TreeNode oldRight = root.right;</span><br><span class="line">    if (root.left != null) &#123;</span><br><span class="line">        root.right = root.left;</span><br><span class="line">        // I missed this line of code:</span><br><span class="line">        root.left = null;</span><br><span class="line">        root = helper(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    if (oldRight != null) &#123;</span><br><span class="line">        root.right = oldRight;</span><br><span class="line">        root = helper(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    // return value is the last element of the flatten tree</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Third, stack non-recursive solution</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void flatten(TreeNode root) &#123;</span><br><span class="line">	TreeNode cur = root;</span><br><span class="line">	Stack&lt;TreeNode&gt; rtrees = new Stack&lt;TreeNode&gt;();</span><br><span class="line">	while (cur != null) &#123;</span><br><span class="line">		while (cur.left != null) &#123;</span><br><span class="line">			if (cur.right != null)</span><br><span class="line">				rtrees.push(cur.right);</span><br><span class="line">			cur.right = cur.left;</span><br><span class="line">			cur.left = null;</span><br><span class="line">			cur = cur.right;</span><br><span class="line">		&#125;</span><br><span class="line">		if (cur != null &amp;&amp; cur.right == null &amp;&amp; !rtrees.isEmpty()) &#123;</span><br><span class="line">			cur.right = rtrees.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		cur = cur.right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Fourth, non-stack non-recursive solution</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void flatten(TreeNode root) &#123;</span><br><span class="line">	TreeNode cur = root;</span><br><span class="line">	while (cur != null) &#123;</span><br><span class="line">		if (cur.left != null) &#123;</span><br><span class="line">			if (cur.right != null) &#123; // if we need to prune a right subtree</span><br><span class="line">				TreeNode next = cur.left;</span><br><span class="line">				while (next.right != null)</span><br><span class="line">					next = next.right;</span><br><span class="line">				next.right = cur.right;</span><br><span class="line">			&#125;</span><br><span class="line">			cur.right = cur.left;</span><br><span class="line">			cur.left = null;</span><br><span class="line">		&#125;</span><br><span class="line">		cur = cur.right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</main>

</article>


<script src="/js/highlight.js"></script>

  </main>
  <footer class="footer">
  
  <span>Copyright © 2024 typo</span>
  
</footer>
  
<script src="/js/theme.js"></script>

</body>

</html>