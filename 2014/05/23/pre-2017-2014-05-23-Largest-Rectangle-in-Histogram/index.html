<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">





<title>[LeetCode 84] Largest Rectangle in Histogram | Tech blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const pagebody = document.getElementsByTagName('body')[0]

            function setTheme(status) {

                if (status === 'dark') {
                    window.sessionStorage.theme = 'dark'
                    pagebody.classList.add('dark-theme');

                } else if (status === 'light') {
                    window.sessionStorage.theme = 'light'
                    pagebody.classList.remove('dark-theme');
                }
            };

            setTheme(window.sessionStorage.theme)
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Bentham&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/category">Categories</a>
                
                <a class="menu-item" href="/tag">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Bentham&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">
                    <svg class="menu-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M4.5 17.27q-.213 0-.356-.145T4 16.768t.144-.356t.356-.143h15q.213 0 .356.144q.144.144.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.144T4 11.999t.144-.356t.356-.143h15q.213 0 .356.144t.144.357t-.144.356t-.356.143zm0-4.77q-.213 0-.356-.143Q4 7.443 4 7.23t.144-.356t.356-.143h15q.213 0 .356.144T20 7.23t-.144.356t-.356.144z"/></svg>
                    <svg class="close-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Material Symbols Light by Google - https://github.com/google/material-design-icons/blob/master/LICENSE --><path fill="currentColor" d="m12 12.708l-5.246 5.246q-.14.14-.344.15t-.364-.15t-.16-.354t.16-.354L11.292 12L6.046 6.754q-.14-.14-.15-.344t.15-.364t.354-.16t.354.16L12 11.292l5.246-5.246q.14-.14.345-.15q.203-.01.363.15t.16.354t-.16.354L12.708 12l5.246 5.246q.14.14.15.345q.01.203-.15.363t-.354.16t-.354-.16z"/></svg>
                </div>
            </div>
            <div class="menu" id="mobile-menu">
                
                <a class="menu-item" href="/archives">Posts</a>
                
                <a class="menu-item" href="/category">Categories</a>
                
                <a class="menu-item" href="/tag">Tags</a>
                
                <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.classList.contains("active")) {
            toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        } else {
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">[LeetCode 84] Largest Rectangle in Histogram</h1>
            
                <div class="post-meta">
                    

                    
                        <span class="post-time">
                        Date: <a href="#">May 23, 2014&nbsp;&nbsp;0:00:00</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Leetcode/">Leetcode</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p><a target="_blank" rel="noopener" href="https://oj.leetcode.com/problems/largest-rectangle-in-histogram/">link</a></p>
<div class="question-content">
            <p></p><p>
Given <i>n</i> non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.
</p>

<p>
<img src="http://www.leetcode.com/wp-content/uploads/2012/04/histogram.png"><br>
</p><p style="font-size: 11px">Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p>
<p></p>

<p>
<img src="http://www.leetcode.com/wp-content/uploads/2012/04/histogram_area.png"><br>
</p><p style="font-size: 11px">The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p>
<p></p>

<p>
For example,<br>
Given height = <code>[2,1,5,6,2,3]</code>,<br>
return <code>10</code>.
</p><p></p>
          </div>

<h3 id="Stats"><a href="#Stats" class="headerlink" title="Stats"></a>Stats</h3><table border="2">
	<tr>
		<td>Frequency</td>
		<td bgcolor="lime">2</td>
	</tr>
	<tr>
		<td>Difficulty</td>
		<td bgcolor="red">5</td>
	</tr>
	<tr>
		<td>Adjusted Difficulty</td>
		<td bgcolor="red">5</td>
	</tr>
	<tr>
		<td>Time to use</td>
		<td bgcolor="red">----------</td>
	</tr>
</table>

<p>Ratings&#x2F;Color &#x3D; 1(white) 2(lime) 3(yellow) 4&#x2F;5(red)</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p><strong>This is an extremely difficult question</strong>.</p>
<p>The idea of the solution (using stack) seems understandable, but can be very tricky when coding.</p>
<p><strong>The basic idea is, always keep increasing elements in the stack</strong>. When I see a decrease in number, pop stack. And I calculate max area only when poping elements. In the end, a ‘0’ is inserted to the end, so that all stack item will be popped (and at the same time, max area been calculated).</p>
<p>Sorry if I did not explain well enough. <a target="_blank" rel="noopener" href="http://www.geeksforgeeks.org/largest-rectangle-under-histogram/">Here</a> is a better one:</p>
<blockquote cite="http://www.geeksforgeeks.org/largest-rectangle-under-histogram/">
<p>
We traverse all bars from left to right, maintain a stack of bars.  Every bar is pushed to stack once.  A bar is popped from stack when a bar of smaller height is seen.  When a bar is popped, we calculate the area with the popped bar as smallest bar. How do we get left and right indexes of the popped bar – the current index tells us the ‘right index’ and index of previous item in stack is the ‘left index’.  Following is the complete algorithm.
</p>
<p><strong>1) </strong>Create an empty stack.</p>
<p><strong>2) </strong>Start from first bar, and do following for every bar ‘hist[i]‘ where ‘i’ varies from 0 to n-1.<br>
……<strong>a)</strong> If stack is empty or hist[i] is higher than the bar at top of stack, then push ‘i’ to stack.<br>
……<strong>b)</strong> If this bar is smaller than the top of stack, then keep removing the top of stack while top of the stack is greater. Let the removed bar be hist[tp]. Calculate area  of rectangle with hist[tp] as smallest bar. For hist[tp], the ‘left index’ is previous (previous to tp) item in stack and ‘right index’ is ‘i’ (current index).</p>
<p><strong>3)</strong> If the stack is not empty, then one by one remove all bars from stack and do step 2.b for every removed bar.</p>
</blockquote>

<p>Time complexity of the stack solution is <strong>O(n)</strong>. (Another algo analysis article <a target="_blank" rel="noopener" href="http://tech-queries.blogspot.sg/2011/03/maximum-area-rectangle-in-histogram.html">here</a>)</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p><strong>I wrote the code using idea from <a target="_blank" rel="noopener" href="http://jane4532.blogspot.sg/2013/07/longest-rectangle-in-histogramleetcode.html">blog</a></strong>. It works, but there are 2 things that I got wrong.</p>
<p><strong>First, if elements are equal</strong>. I shall also push it. I can not simply skip it, I don’t know why!</p>
<blockquote>
<p>if (stack.isEmpty() || cur &gt;&#x3D; height[stack.peek()])</p>
</blockquote>
<p><strong>Second, about how to calculate the width of the rectangle</strong>. I used this before:</p>
<blockquote>
<p>int width &#x3D; stack.isEmpty() ? p : p - h;</p>
</blockquote>
<p>It’s wrong, I must get the value of next element from stack, and then calculate width. Why? there might be element been popped before, which locate between these 2 elements in stack.</p>
<blockquote>
<p>int width &#x3D; stack.isEmpty() ? p : p - stack.peek() - 1;</p>
</blockquote>
<p><strong>Updated on July 4th, 2014</strong>: the above 2 points are very valid, especially the second. Keep in mind:</p>
<ol>
<li><p>The values in stack means the last position that a height can be found. For example, height is (2, 10, 5) then the stack would have (2, removed, 5). When calculating the area for height 5, we should note the removed space is in consideration as well.</p>
</li>
<li><p>So, when equal height is found, pop it. Because you won’t need it any more. The stack only stores last position this height is found.</p>
</li>
<li><p>When stack is empty, the width of rectange should be calculated from 0.</p>
</li>
</ol>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p><strong>My code written on July 4th, 2014</strong></p>
<pre><code>public int largestRectangleArea(int[] height) &#123;
    if (height == null || height.length == 0) &#123;
        return 0;
    &#125;
    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
    stack.add(0);
    int len = height.length;
    int area = 0;
    for (int i = 1; i &lt;= len; i++) &#123;
        int h = i == len ? 0 : height[i];
        // pop a element and calculate its max area
        // pop until the top element is smaller than h, then push h
        while (!stack.isEmpty() &amp;&amp; h &lt;= height[stack.peek()]) &#123;
            int pos = stack.pop();
            int width = stack.isEmpty() ? i : i - stack.peek() - 1;
            area = Math.max(area, height[pos] * width);
        &#125;
        stack.push(i);
    &#125;
    return area;
&#125;
</code></pre>
<p><strong>My code written on July 18th, 2014</strong></p>
<pre><code>public int largestRectangleArea(int[] height) &#123;
    if (height == null || height.length == 0) &#123;
		return 0;
	&#125;
	int maxArea = Integer.MIN_VALUE;
	Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
	int p = 0;
	while (p &lt; height.length) &#123;
		if (stack.isEmpty() || height[stack.peek()] &lt;= height[p]) &#123;
			stack.push(p);
			p++;
		&#125; else &#123;
			int h = stack.pop();
		    int w = stack.isEmpty() ? p : p - stack.peek() - 1;
			int area = height[h] * w;
			maxArea = Math.max(maxArea, area);
		&#125;
	&#125;
	while (!stack.isEmpty()) &#123;
		int h = stack.pop();
		int w = stack.isEmpty() ? p : p - stack.peek() -1;
		int area = height[h] * w;
		maxArea = Math.max(maxArea, area);
	&#125;
	return maxArea;
&#125;
</code></pre>
<p><strong>Updated Oct 29, 2022</strong></p>
<p>这道题一言难尽。</p>
<p>反正勉强算是写出来了，明明不难，不过需要注意思考一下 index 和 height 的关系。</p>
<p>以下代码不过 OJ，因为超时。不过我觉得可以 work。优化只要用二分搜索就好。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Pair &#123;</span><br><span class="line">    int index;</span><br><span class="line">    int height;</span><br><span class="line">    public Pair (int x, int y) &#123;</span><br><span class="line">        index = x;</span><br><span class="line">        height = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int largestRectangleArea(int[] heights) &#123;</span><br><span class="line">    int len = heights.length;</span><br><span class="line">    List&lt;Pair&gt; list = new ArrayList&lt;Pair&gt;();</span><br><span class="line">    int area = heights[0];</span><br><span class="line">    list.add(new Pair(0, heights[0]));</span><br><span class="line">    for (int i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        // make sure the list is a singly increasing list of heights</span><br><span class="line">        Pair p = new Pair(i, 0);</span><br><span class="line">        while (list.size() &gt; 0 &amp;&amp; list.get(list.size() - 1).height &gt;= heights[i]) &#123;</span><br><span class="line">            // Important: this part change to binary search</span><br><span class="line">            // can optimize performance</span><br><span class="line">            p = list.remove(list.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">        p.height = heights[i];</span><br><span class="line">        list.add(p);</span><br><span class="line"></span><br><span class="line">        for (Pair pp: list) &#123;</span><br><span class="line">            int tmpArea = (i - pp.index + 1) * pp.height;</span><br><span class="line">            area = Math.max(area, tmpArea);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://mar2ndx.github.io/2014/05/23/pre-2017-2014-05-23-Largest-Rectangle-in-Histogram/">https://mar2ndx.github.io/2014/05/23/pre-2017-2014-05-23-Largest-Rectangle-in-Histogram/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2014/05/23/pre-2017-2014-05-23-Gray-Code/">[LeetCode 89] Gray Code</a>
            
            
            <a class="next" rel="next" href="/2014/05/23/pre-2017-2014-05-23-Merge-Sorted-Array/">[LeetCode 88] Merge Sorted Array</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>©  | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>